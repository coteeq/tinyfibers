# API

## `RunScheduler`

Вызов функции `RunScheduler` разворачивает _планировщик_ (_scheduler_) и запускает в нем _файбер_ (_fiber_), который исполняет переданную _процедуру_ (_routine_):


```cpp
RunScheduler([] {
  fmt::println("I'm a fiber");
});
```

Планировщик файберов реализован в пространстве пользователя и детерминированно планирует файберы в одном потоке операционной системы (в том потоке, который вызвал `RunScheduler`).

Планировщик поддерживает очередь готовых исполняться файберов – _run queue_.

На каждой итерации цикла планирования планировщик извлекает из головы _run queue_ очередной файбер и передает ему управление. 
Запущенный файбер исполняется до тех пор, пока либо не завершит свою процедуру, либо добровольно не отдаст управление (например, вызвав `Yield`).

Вызов `RunScheduler` завершится тогда, когда планировщик исчерпает работу, т.е. когда в _run queue_ не останется файберов.

## `Yield`

Вызов `Yield()` останавливает исполнение текущего файбера и возвращает управление планировщику. Планировщик в свою очередь помещает вернувший управление файбер в хвост _run queue_ и переходит к следующей итерации цикла планирования.

## `Spawn`

Функция `Spawn` создает новый файбер и помещает его в хвост _run queue_.

Сам по себе вызов `Spawn` не приводит к передаче управления и моментальному запуску нового файбера: новый файбер лишь планируется на исполнение, а управление остается у файбера, вызвавшего `Spawn`.

```cpp
bool started = false;
JoinHandle h = Spawn([&] {
  started = true;
  // ...
});
assert(!started);
```

### `JoinHandle`

Вызов `Spawn` возвращает объект `JoinHandle` с помощью которого файбер-родитель может дождаться завершения запущенного файбера-ребенка.

#### `Join`

Останавливает файбер, вызвавший `Join`, до тех пор, пока не завершится файбер, с которым связан данный `JoinHandle`:

```cpp
JoinHandle h = Spawn([] {
  // ...
});
h.Join();  // Дожидаемся завершения запущенного файбера, отдаем управление
```

#### `Detach`

"Отвязывает" экземпляр `JoinHandle` от ассоциированного с ним файбера, последний отправляется в "свободное плавание".

#### Правила

Методы `Join` и `Detach` – взаимоисключающие, вызвать можно только один из них и только один раз.

Пользователь обязан вызвать или `Join` или `Detach`.

В противном случае – UB.

## Синхронизация

- `Mutex`
- `CondVar`
