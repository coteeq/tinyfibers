# API

## `RunScheduler`

Вызов функции `RunScheduler` разворачивает _планировщик_ (_scheduler_) и запускает в нем _файбер_ (_fiber_), который исполняет переданную функцию:


```cpp
RunScheduler([]() {
  fmt::println("I'm a fiber");
});
```

Планировщик файберов реализован в пространстве пользователя и детерминированно планирует файберы в одном потоке операционной системы.

Планировщик поддерживает очередь готовых исполняться файберов – _run queue_.

На каждой итерации цикла планирования планировщик извлекает из головы _run queue_ очередной файбер и запускает его. Запущенный файбер исполняется до тех пор, пока либо не завершит исполнение своей функции, либо добровольно не отдаст управление (например, вызвав `Yield` ).

Вызов `RunScheduler` завершается тогда, когда планировщик исчерпает работу, т.е. когда _run queue_ станет пустой.

## `Yield`

Вызов `self::Yield()` останавливает исполнение текущего файбера и возвращает управление планировщику. Планировщик в свою очередь помещает остановившийся файбер в хвост _run queue_ и переходит к следующей итерации цикла планирования.

## `Spawn`

Функция `Spawn` создает новый файбер и помещает его в хвост _run queue_.

Сам по себе вызов функции `Spawn` не приводит к передаче управления и моментальному запуску нового файбера: новый файбер лишь планируется на исполнение, а управление остается у файбера, вызвавшего `Spawn`.

```cpp
bool started = false;
JoinHandle h = Spawn([&]() {
  started = true;
  // ...
});
assert(!started);
```

### `JoinHandle`

Вызов `Spawn` возвращает объект `JoinHandle` с помощью которого файбер-родитель может дождаться завершения запущенного файбера-ребенка.

#### `Join`

Блокирует файбер, вызвавший `Join`, до тех пор, пока не завершится файбер, с которым связан данный `JoinHandle`:

```cpp
JoinHandle child = Spawn([]() {
  // ...
});
child.Join();  // Дожидаемся завершения запущенного файбера, отдаем управление
```

#### `Detach`

"Отвязывает" экземпляр `JoinHandle` от ассоциированного с ним файбера, последний отправляется в "свободное плавание".

#### Правила

Методы `Join` и `Detach` – взаимоисключающие, вызвать можно только один из них и только один раз.

Пользователь обязан вызвать или `Join` или `Detach`.

В противном случае – UB.

## Синхронизация

- `Mutex`
- `CondVar`